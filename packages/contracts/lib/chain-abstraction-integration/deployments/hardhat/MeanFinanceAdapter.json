{
  "address": "0xa85233C63b9Ee964Add6F2cffe00Fd84eb32338f",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        },
        {
          "internalType": "uint32",
          "name": "_amountOfSwaps",
          "type": "uint32"
        },
        {
          "internalType": "uint32",
          "name": "_swapInterval",
          "type": "uint32"
        },
        {
          "internalType": "address",
          "name": "_owner",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "operator",
              "type": "address"
            },
            {
              "internalType": "enum IDCAPermissionManager.Permission[]",
              "name": "permissions",
              "type": "uint8[]"
            }
          ],
          "internalType": "struct IDCAPermissionManager.PermissionSet[]",
          "name": "_permissions",
          "type": "tuple[]"
        }
      ],
      "name": "deposit",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "_positionId",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "hub",
      "outputs": [
        {
          "internalType": "contract IDCAHub",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "stateMutability": "payable",
      "type": "receive"
    }
  ],
  "transactionHash": "0x7e5b7e016c77757b3d17e97c0901125fce35ac22ef341d3b1c021d8985595b02",
  "receipt": {
    "to": null,
    "from": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "contractAddress": "0xa85233C63b9Ee964Add6F2cffe00Fd84eb32338f",
    "transactionIndex": 0,
    "gasUsed": "661661",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xb931f92d53a2e18e650e288342a5e354a19963f776717db27ee3a05c63506020",
    "transactionHash": "0x7e5b7e016c77757b3d17e97c0901125fce35ac22ef341d3b1c021d8985595b02",
    "logs": [],
    "blockNumber": 73304257,
    "cumulativeGasUsed": "661661",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "64c36384f36066b6f50911fe7c827894",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_amountOfSwaps\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_swapInterval\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"enum IDCAPermissionManager.Permission[]\",\"name\":\"permissions\",\"type\":\"uint8[]\"}],\"internalType\":\"struct IDCAPermissionManager.PermissionSet[]\",\"name\":\"_permissions\",\"type\":\"tuple[]\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_positionId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hub\",\"outputs\":[{\"internalType\":\"contract IDCAHub\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"deposit(address,address,uint256,uint32,uint32,address,(address,uint8[])[])\":{\"params\":{\"_amount\":\"How many \\\"from\\\" tokens will be swapped in total\",\"_amountOfSwaps\":\"How many swaps to execute for this position\",\"_from\":\"The address of the \\\"from\\\" token\",\"_owner\":\"The address of the owner of the position being created\",\"_swapInterval\":\"How frequently the position's swaps should be executed\",\"_to\":\"The address of the \\\"to\\\" token\"},\"returns\":{\"_positionId\":\"The id of the created position\"}}},\"stateVariables\":{\"hub\":{\"details\":\"see https://docs.mean.finance/guides/smart-contract-registry\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"deposit(address,address,uint256,uint32,uint32,address,(address,uint8[])[])\":{\"notice\":\"Creates a new position\"},\"hub()\":{\"notice\":\"MeanFinance IDCAHub contract for deposit\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/MeanFinance/MeanFinanceAdapter.sol\":\"MeanFinanceAdapter\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"@mean-finance/dca-v2-core/contracts/interfaces/IDCAHub.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.7 <0.9.0;\\n\\nimport '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\\nimport '@mean-finance/oracles/solidity/interfaces/ITokenPriceOracle.sol';\\nimport './IDCAPermissionManager.sol';\\n\\n/**\\n * @title The interface for all state related queries\\n * @notice These methods allow users to read the hubs's current values\\n */\\ninterface IDCAHubParameters {\\n  /**\\n   * @notice Returns how much will the amount to swap differ from the previous swap. f.e. if the returned value is -100, then the amount to swap will be 100 less than the swap just before it\\n   * @dev `tokenA` must be smaller than `tokenB` (tokenA < tokenB)\\n   * @param tokenA One of the pair's token\\n   * @param tokenB The other of the pair's token\\n   * @param swapIntervalMask The byte representation of the swap interval to check\\n   * @param swapNumber The swap number to check\\n   * @return swapDeltaAToB How much less of token A will the following swap require\\n   * @return swapDeltaBToA How much less of token B will the following swap require\\n   */\\n  function swapAmountDelta(\\n    address tokenA,\\n    address tokenB,\\n    bytes1 swapIntervalMask,\\n    uint32 swapNumber\\n  ) external view returns (uint128 swapDeltaAToB, uint128 swapDeltaBToA);\\n\\n  /**\\n   * @notice Returns the sum of the ratios reported in all swaps executed until the given swap number\\n   * @dev `tokenA` must be smaller than `tokenB` (tokenA < tokenB)\\n   * @param tokenA One of the pair's token\\n   * @param tokenB The other of the pair's token\\n   * @param swapIntervalMask The byte representation of the swap interval to check\\n   * @param swapNumber The swap number to check\\n   * @return accumRatioAToB The sum of all ratios from A to B\\n   * @return accumRatioBToA The sum of all ratios from B to A\\n   */\\n  function accumRatio(\\n    address tokenA,\\n    address tokenB,\\n    bytes1 swapIntervalMask,\\n    uint32 swapNumber\\n  ) external view returns (uint256 accumRatioAToB, uint256 accumRatioBToA);\\n\\n  /**\\n   * @notice Returns swapping information about a specific pair\\n   * @dev `tokenA` must be smaller than `tokenB` (tokenA < tokenB)\\n   * @param tokenA One of the pair's token\\n   * @param tokenB The other of the pair's token\\n   * @param swapIntervalMask The byte representation of the swap interval to check\\n   * @return performedSwaps How many swaps have been executed\\n   * @return nextAmountToSwapAToB How much of token A will be swapped on the next swap\\n   * @return lastSwappedAt Timestamp of the last swap\\n   * @return nextAmountToSwapBToA How much of token B will be swapped on the next swap\\n   */\\n  function swapData(\\n    address tokenA,\\n    address tokenB,\\n    bytes1 swapIntervalMask\\n  )\\n    external\\n    view\\n    returns (\\n      uint32 performedSwaps,\\n      uint224 nextAmountToSwapAToB,\\n      uint32 lastSwappedAt,\\n      uint224 nextAmountToSwapBToA\\n    );\\n\\n  /**\\n   * @notice Returns the byte representation of the set of actice swap intervals for the given pair\\n   * @dev `tokenA` must be smaller than `tokenB` (tokenA < tokenB)\\n   * @param tokenA The smaller of the pair's token\\n   * @param tokenB The other of the pair's token\\n   * @return The byte representation of the set of actice swap intervals\\n   */\\n  function activeSwapIntervals(address tokenA, address tokenB) external view returns (bytes1);\\n\\n  /**\\n   * @notice Returns how much of the hub's token balance belongs to the platform\\n   * @param token The token to check\\n   * @return The amount that belongs to the platform\\n   */\\n  function platformBalance(address token) external view returns (uint256);\\n}\\n\\n/**\\n * @title The interface for all position related matters\\n * @notice These methods allow users to create, modify and terminate their positions\\n */\\ninterface IDCAHubPositionHandler {\\n  /// @notice The position of a certain user\\n  struct UserPosition {\\n    // The token that the user deposited and will be swapped in exchange for \\\"to\\\"\\n    IERC20Metadata from;\\n    // The token that the user will get in exchange for their \\\"from\\\" tokens in each swap\\n    IERC20Metadata to;\\n    // How frequently the position's swaps should be executed\\n    uint32 swapInterval;\\n    // How many swaps were executed since deposit, last modification, or last withdraw\\n    uint32 swapsExecuted;\\n    // How many \\\"to\\\" tokens can currently be withdrawn\\n    uint256 swapped;\\n    // How many swaps left the position has to execute\\n    uint32 swapsLeft;\\n    // How many \\\"from\\\" tokens there are left to swap\\n    uint256 remaining;\\n    // How many \\\"from\\\" tokens need to be traded in each swap\\n    uint120 rate;\\n  }\\n\\n  /// @notice A list of positions that all have the same `to` token\\n  struct PositionSet {\\n    // The `to` token\\n    address token;\\n    // The position ids\\n    uint256[] positionIds;\\n  }\\n\\n  /**\\n   * @notice Emitted when a position is terminated\\n   * @param user The address of the user that terminated the position\\n   * @param recipientUnswapped The address of the user that will receive the unswapped tokens\\n   * @param recipientSwapped The address of the user that will receive the swapped tokens\\n   * @param positionId The id of the position that was terminated\\n   * @param returnedUnswapped How many \\\"from\\\" tokens were returned to the caller\\n   * @param returnedSwapped How many \\\"to\\\" tokens were returned to the caller\\n   */\\n  event Terminated(\\n    address indexed user,\\n    address indexed recipientUnswapped,\\n    address indexed recipientSwapped,\\n    uint256 positionId,\\n    uint256 returnedUnswapped,\\n    uint256 returnedSwapped\\n  );\\n\\n  /**\\n   * @notice Emitted when a position is created\\n   * @param depositor The address of the user that creates the position\\n   * @param owner The address of the user that will own the position\\n   * @param positionId The id of the position that was created\\n   * @param fromToken The address of the \\\"from\\\" token\\n   * @param toToken The address of the \\\"to\\\" token\\n   * @param swapInterval How frequently the position's swaps should be executed\\n   * @param rate How many \\\"from\\\" tokens need to be traded in each swap\\n   * @param startingSwap The number of the swap when the position will be executed for the first time\\n   * @param lastSwap The number of the swap when the position will be executed for the last time\\n   * @param permissions The permissions defined for the position\\n   */\\n  event Deposited(\\n    address indexed depositor,\\n    address indexed owner,\\n    uint256 positionId,\\n    address fromToken,\\n    address toToken,\\n    uint32 swapInterval,\\n    uint120 rate,\\n    uint32 startingSwap,\\n    uint32 lastSwap,\\n    IDCAPermissionManager.PermissionSet[] permissions\\n  );\\n\\n  /**\\n   * @notice Emitted when a position is created and extra data is provided\\n   * @param positionId The id of the position that was created\\n   * @param data The extra data that was provided\\n   */\\n  event Miscellaneous(uint256 positionId, bytes data);\\n\\n  /**\\n   * @notice Emitted when a user withdraws all swapped tokens from a position\\n   * @param withdrawer The address of the user that executed the withdraw\\n   * @param recipient The address of the user that will receive the withdrawn tokens\\n   * @param positionId The id of the position that was affected\\n   * @param token The address of the withdrawn tokens. It's the same as the position's \\\"to\\\" token\\n   * @param amount The amount that was withdrawn\\n   */\\n  event Withdrew(address indexed withdrawer, address indexed recipient, uint256 positionId, address token, uint256 amount);\\n\\n  /**\\n   * @notice Emitted when a user withdraws all swapped tokens from many positions\\n   * @param withdrawer The address of the user that executed the withdraws\\n   * @param recipient The address of the user that will receive the withdrawn tokens\\n   * @param positions The positions to withdraw from\\n   * @param withdrew The total amount that was withdrawn from each token\\n   */\\n  event WithdrewMany(address indexed withdrawer, address indexed recipient, PositionSet[] positions, uint256[] withdrew);\\n\\n  /**\\n   * @notice Emitted when a position is modified\\n   * @param user The address of the user that modified the position\\n   * @param positionId The id of the position that was modified\\n   * @param rate How many \\\"from\\\" tokens need to be traded in each swap\\n   * @param startingSwap The number of the swap when the position will be executed for the first time\\n   * @param lastSwap The number of the swap when the position will be executed for the last time\\n   */\\n  event Modified(address indexed user, uint256 positionId, uint120 rate, uint32 startingSwap, uint32 lastSwap);\\n\\n  /// @notice Thrown when a user tries to create a position with the same `from` & `to`\\n  error InvalidToken();\\n\\n  /// @notice Thrown when a user tries to create a position with a swap interval that is not allowed\\n  error IntervalNotAllowed();\\n\\n  /// @notice Thrown when a user tries operate on a position that doesn't exist (it might have been already terminated)\\n  error InvalidPosition();\\n\\n  /// @notice Thrown when a user tries operate on a position that they don't have access to\\n  error UnauthorizedCaller();\\n\\n  /// @notice Thrown when a user tries to create a position with zero swaps\\n  error ZeroSwaps();\\n\\n  /// @notice Thrown when a user tries to create a position with zero funds\\n  error ZeroAmount();\\n\\n  /// @notice Thrown when a user tries to withdraw a position whose `to` token doesn't match the specified one\\n  error PositionDoesNotMatchToken();\\n\\n  /// @notice Thrown when a user tries create or modify a position with an amount too big\\n  error AmountTooBig();\\n\\n  /**\\n   * @notice Returns the permission manager contract\\n   * @return The contract itself\\n   */\\n  function permissionManager() external view returns (IDCAPermissionManager);\\n\\n  /**\\n   * @notice Returns total created positions\\n   * @return The total created positions\\n   */\\n  function totalCreatedPositions() external view returns (uint256);\\n\\n  /**\\n   * @notice Returns a user position\\n   * @param positionId The id of the position\\n   * @return position The position itself\\n   */\\n  function userPosition(uint256 positionId) external view returns (UserPosition memory position);\\n\\n  /**\\n   * @notice Creates a new position\\n   * @dev Will revert:\\n   *      - With ZeroAddress if from, to or owner are zero\\n   *      - With InvalidToken if from == to\\n   *      - With ZeroAmount if amount is zero\\n   *      - With AmountTooBig if amount is too big\\n   *      - With ZeroSwaps if amountOfSwaps is zero\\n   *      - With IntervalNotAllowed if swapInterval is not allowed\\n   * @param from The address of the \\\"from\\\" token\\n   * @param to The address of the \\\"to\\\" token\\n   * @param amount How many \\\"from\\\" tokens will be swapped in total\\n   * @param amountOfSwaps How many swaps to execute for this position\\n   * @param swapInterval How frequently the position's swaps should be executed\\n   * @param owner The address of the owner of the position being created\\n   * @param permissions Extra permissions to add to the position. Can be empty\\n   * @return positionId The id of the created position\\n   */\\n  function deposit(\\n    address from,\\n    address to,\\n    uint256 amount,\\n    uint32 amountOfSwaps,\\n    uint32 swapInterval,\\n    address owner,\\n    IDCAPermissionManager.PermissionSet[] calldata permissions\\n  ) external returns (uint256 positionId);\\n\\n  /**\\n   * @notice Creates a new position\\n   * @dev Will revert:\\n   *      - With ZeroAddress if from, to or owner are zero\\n   *      - With InvalidToken if from == to\\n   *      - With ZeroAmount if amount is zero\\n   *      - With AmountTooBig if amount is too big\\n   *      - With ZeroSwaps if amountOfSwaps is zero\\n   *      - With IntervalNotAllowed if swapInterval is not allowed\\n   * @param from The address of the \\\"from\\\" token\\n   * @param to The address of the \\\"to\\\" token\\n   * @param amount How many \\\"from\\\" tokens will be swapped in total\\n   * @param amountOfSwaps How many swaps to execute for this position\\n   * @param swapInterval How frequently the position's swaps should be executed\\n   * @param owner The address of the owner of the position being created\\n   * @param permissions Extra permissions to add to the position. Can be empty\\n   * @param miscellaneous Bytes that will be emitted, and associated with the position\\n   * @return positionId The id of the created position\\n   */\\n  function deposit(\\n    address from,\\n    address to,\\n    uint256 amount,\\n    uint32 amountOfSwaps,\\n    uint32 swapInterval,\\n    address owner,\\n    IDCAPermissionManager.PermissionSet[] calldata permissions,\\n    bytes calldata miscellaneous\\n  ) external returns (uint256 positionId);\\n\\n  /**\\n   * @notice Withdraws all swapped tokens from a position to a recipient\\n   * @dev Will revert:\\n   *      - With InvalidPosition if positionId is invalid\\n   *      - With UnauthorizedCaller if the caller doesn't have access to the position\\n   *      - With ZeroAddress if recipient is zero\\n   * @param positionId The position's id\\n   * @param recipient The address to withdraw swapped tokens to\\n   * @return swapped How much was withdrawn\\n   */\\n  function withdrawSwapped(uint256 positionId, address recipient) external returns (uint256 swapped);\\n\\n  /**\\n   * @notice Withdraws all swapped tokens from multiple positions\\n   * @dev Will revert:\\n   *      - With InvalidPosition if any of the position ids are invalid\\n   *      - With UnauthorizedCaller if the caller doesn't have access to the position to any of the given positions\\n   *      - With ZeroAddress if recipient is zero\\n   *      - With PositionDoesNotMatchToken if any of the positions do not match the token in their position set\\n   * @param positions A list positions, grouped by `to` token\\n   * @param recipient The address to withdraw swapped tokens to\\n   * @return withdrawn How much was withdrawn for each token\\n   */\\n  function withdrawSwappedMany(PositionSet[] calldata positions, address recipient) external returns (uint256[] memory withdrawn);\\n\\n  /**\\n   * @notice Takes the unswapped balance, adds the new deposited funds and modifies the position so that\\n   * it is executed in newSwaps swaps\\n   * @dev Will revert:\\n   *      - With InvalidPosition if positionId is invalid\\n   *      - With UnauthorizedCaller if the caller doesn't have access to the position\\n   *      - With AmountTooBig if amount is too big\\n   * @param positionId The position's id\\n   * @param amount Amount of funds to add to the position\\n   * @param newSwaps The new amount of swaps\\n   */\\n  function increasePosition(\\n    uint256 positionId,\\n    uint256 amount,\\n    uint32 newSwaps\\n  ) external;\\n\\n  /**\\n   * @notice Withdraws the specified amount from the unswapped balance and modifies the position so that\\n   * it is executed in newSwaps swaps\\n   * @dev Will revert:\\n   *      - With InvalidPosition if positionId is invalid\\n   *      - With UnauthorizedCaller if the caller doesn't have access to the position\\n   *      - With ZeroSwaps if newSwaps is zero and amount is not the total unswapped balance\\n   * @param positionId The position's id\\n   * @param amount Amount of funds to withdraw from the position\\n   * @param newSwaps The new amount of swaps\\n   * @param recipient The address to send tokens to\\n   */\\n  function reducePosition(\\n    uint256 positionId,\\n    uint256 amount,\\n    uint32 newSwaps,\\n    address recipient\\n  ) external;\\n\\n  /**\\n   * @notice Terminates the position and sends all unswapped and swapped balance to the specified recipients\\n   * @dev Will revert:\\n   *      - With InvalidPosition if positionId is invalid\\n   *      - With UnauthorizedCaller if the caller doesn't have access to the position\\n   *      - With ZeroAddress if recipientUnswapped or recipientSwapped is zero\\n   * @param positionId The position's id\\n   * @param recipientUnswapped The address to withdraw unswapped tokens to\\n   * @param recipientSwapped The address to withdraw swapped tokens to\\n   * @return unswapped The unswapped balance sent to `recipientUnswapped`\\n   * @return swapped The swapped balance sent to `recipientSwapped`\\n   */\\n  function terminate(\\n    uint256 positionId,\\n    address recipientUnswapped,\\n    address recipientSwapped\\n  ) external returns (uint256 unswapped, uint256 swapped);\\n}\\n\\n/**\\n * @title The interface for all swap related matters\\n * @notice These methods allow users to get information about the next swap, and how to execute it\\n */\\ninterface IDCAHubSwapHandler {\\n  /// @notice Information about a swap\\n  struct SwapInfo {\\n    // The tokens involved in the swap\\n    TokenInSwap[] tokens;\\n    // The pairs involved in the swap\\n    PairInSwap[] pairs;\\n  }\\n\\n  /// @notice Information about a token's role in a swap\\n  struct TokenInSwap {\\n    // The token's address\\n    address token;\\n    // How much will be given of this token as a reward\\n    uint256 reward;\\n    // How much of this token needs to be provided by swapper\\n    uint256 toProvide;\\n    // How much of this token will be paid to the platform\\n    uint256 platformFee;\\n  }\\n\\n  /// @notice Information about a pair in a swap\\n  struct PairInSwap {\\n    // The address of one of the tokens\\n    address tokenA;\\n    // The address of the other token\\n    address tokenB;\\n    // The total amount of token A swapped in this pair\\n    uint256 totalAmountToSwapTokenA;\\n    // The total amount of token B swapped in this pair\\n    uint256 totalAmountToSwapTokenB;\\n    // How much is 1 unit of token A when converted to B\\n    uint256 ratioAToB;\\n    // How much is 1 unit of token B when converted to A\\n    uint256 ratioBToA;\\n    // The swap intervals involved in the swap, represented as a byte\\n    bytes1 intervalsInSwap;\\n  }\\n\\n  /// @notice A pair of tokens, represented by their indexes in an array\\n  struct PairIndexes {\\n    // The index of the token A\\n    uint8 indexTokenA;\\n    // The index of the token B\\n    uint8 indexTokenB;\\n  }\\n\\n  /**\\n   * @notice Emitted when a swap is executed\\n   * @param sender The address of the user that initiated the swap\\n   * @param rewardRecipient The address that received the reward\\n   * @param callbackHandler The address that executed the callback\\n   * @param swapInformation All information related to the swap\\n   * @param borrowed How much was borrowed\\n   * @param fee The swap fee at the moment of the swap\\n   */\\n  event Swapped(\\n    address indexed sender,\\n    address indexed rewardRecipient,\\n    address indexed callbackHandler,\\n    SwapInfo swapInformation,\\n    uint256[] borrowed,\\n    uint32 fee\\n  );\\n\\n  /// @notice Thrown when pairs indexes are not sorted correctly\\n  error InvalidPairs();\\n\\n  /// @notice Thrown when trying to execute a swap, but there is nothing to swap\\n  error NoSwapsToExecute();\\n\\n  /**\\n   * @notice Returns all information related to the next swap\\n   * @dev Will revert with:\\n   *      - With InvalidTokens if tokens are not sorted, or if there are duplicates\\n   *      - With InvalidPairs if pairs are not sorted (first by indexTokenA and then indexTokenB), or if indexTokenA >= indexTokenB for any pair\\n   * @param tokens The tokens involved in the next swap\\n   * @param pairs The pairs that you want to swap. Each element of the list points to the index of the token in the tokens array\\n   * @param calculatePrivilegedAvailability Some accounts get privileged availability and can execute swaps before others. This flag provides\\n   *        the possibility to calculate the next swap information for privileged and non-privileged accounts\\n   * @param oracleData Bytes to send to the oracle when executing a quote\\n   * @return swapInformation The information about the next swap\\n   */\\n  function getNextSwapInfo(\\n    address[] calldata tokens,\\n    PairIndexes[] calldata pairs,\\n    bool calculatePrivilegedAvailability,\\n    bytes calldata oracleData\\n  ) external view returns (SwapInfo memory swapInformation);\\n\\n  /**\\n   * @notice Executes a flash swap\\n   * @dev Will revert with:\\n   *      - With InvalidTokens if tokens are not sorted, or if there are duplicates\\n   *      - With InvalidPairs if pairs are not sorted (first by indexTokenA and then indexTokenB), or if indexTokenA >= indexTokenB for any pair\\n   *      - With Paused if swaps are paused by protocol\\n   *      - With NoSwapsToExecute if there are no swaps to execute for the given pairs\\n   *      - With LiquidityNotReturned if the required tokens were not back during the callback\\n   * @param tokens The tokens involved in the next swap\\n   * @param pairsToSwap The pairs that you want to swap. Each element of the list points to the index of the token in the tokens array\\n   * @param rewardRecipient The address to send the reward to\\n   * @param callbackHandler Address to call for callback (and send the borrowed tokens to)\\n   * @param borrow How much to borrow of each of the tokens in tokens. The amount must match the position of the token in the tokens array\\n   * @param callbackData Bytes to send to the caller during the callback\\n   * @param oracleData Bytes to send to the oracle when executing a quote\\n   * @return Information about the executed swap\\n   */\\n  function swap(\\n    address[] calldata tokens,\\n    PairIndexes[] calldata pairsToSwap,\\n    address rewardRecipient,\\n    address callbackHandler,\\n    uint256[] calldata borrow,\\n    bytes calldata callbackData,\\n    bytes calldata oracleData\\n  ) external returns (SwapInfo memory);\\n}\\n\\n/**\\n * @title The interface for handling all configuration\\n * @notice This contract will manage configuration that affects all pairs, swappers, etc\\n */\\ninterface IDCAHubConfigHandler {\\n  /**\\n   * @notice Emitted when a new oracle is set\\n   * @param oracle The new oracle contract\\n   */\\n  event OracleSet(ITokenPriceOracle oracle);\\n\\n  /**\\n   * @notice Emitted when a new swap fee is set\\n   * @param feeSet The new swap fee\\n   */\\n  event SwapFeeSet(uint32 feeSet);\\n\\n  /**\\n   * @notice Emitted when new swap intervals are allowed\\n   * @param swapIntervals The new swap intervals\\n   */\\n  event SwapIntervalsAllowed(uint32[] swapIntervals);\\n\\n  /**\\n   * @notice Emitted when some swap intervals are no longer allowed\\n   * @param swapIntervals The swap intervals that are no longer allowed\\n   */\\n  event SwapIntervalsForbidden(uint32[] swapIntervals);\\n\\n  /**\\n   * @notice Emitted when a new platform fee ratio is set\\n   * @param platformFeeRatio The new platform fee ratio\\n   */\\n  event PlatformFeeRatioSet(uint16 platformFeeRatio);\\n\\n  /**\\n   * @notice Emitted when allowed states of tokens are updated\\n   * @param tokens Array of updated tokens\\n   * @param allowed Array of new allow state per token were allowed[i] is the updated state of tokens[i]\\n   */\\n  event TokensAllowedUpdated(address[] tokens, bool[] allowed);\\n\\n  /// @notice Thrown when trying to interact with an unallowed token\\n  error UnallowedToken();\\n\\n  /// @notice Thrown when set allowed tokens input is not valid\\n  error InvalidAllowedTokensInput();\\n\\n  /// @notice Thrown when trying to set a fee higher than the maximum allowed\\n  error HighFee();\\n\\n  /// @notice Thrown when trying to set a fee that is not multiple of 100\\n  error InvalidFee();\\n\\n  /// @notice Thrown when trying to set a fee ratio that is higher that the maximum allowed\\n  error HighPlatformFeeRatio();\\n\\n  /**\\n   * @notice Returns the max fee ratio that can be set\\n   * @dev Cannot be modified\\n   * @return The maximum possible value\\n   */\\n  // solhint-disable-next-line func-name-mixedcase\\n  function MAX_PLATFORM_FEE_RATIO() external view returns (uint16);\\n\\n  /**\\n   * @notice Returns the fee charged on swaps\\n   * @return swapFee The fee itself\\n   */\\n  function swapFee() external view returns (uint32 swapFee);\\n\\n  /**\\n   * @notice Returns the price oracle contract\\n   * @return oracle The contract itself\\n   */\\n  function oracle() external view returns (ITokenPriceOracle oracle);\\n\\n  /**\\n   * @notice Returns how much will the platform take from the fees collected in swaps\\n   * @return The current ratio\\n   */\\n  function platformFeeRatio() external view returns (uint16);\\n\\n  /**\\n   * @notice Returns the max fee that can be set for swaps\\n   * @dev Cannot be modified\\n   * @return maxFee The maximum possible fee\\n   */\\n  // solhint-disable-next-line func-name-mixedcase\\n  function MAX_FEE() external view returns (uint32 maxFee);\\n\\n  /**\\n   * @notice Returns a byte that represents allowed swap intervals\\n   * @return allowedSwapIntervals The allowed swap intervals\\n   */\\n  function allowedSwapIntervals() external view returns (bytes1 allowedSwapIntervals);\\n\\n  /**\\n   * @notice Returns if a token is currently allowed or not\\n   * @return Allowed state of token\\n   */\\n  function allowedTokens(address token) external view returns (bool);\\n\\n  /**\\n   * @notice Returns token's magnitude (10**decimals)\\n   * @return Stored magnitude for token\\n   */\\n  function tokenMagnitude(address token) external view returns (uint120);\\n\\n  /**\\n   * @notice Returns whether swaps and deposits are currently paused\\n   * @return isPaused Whether swaps and deposits are currently paused\\n   */\\n  function paused() external view returns (bool isPaused);\\n\\n  /**\\n   * @notice Sets a new swap fee\\n   * @dev Will revert with HighFee if the fee is higher than the maximum\\n   * @dev Will revert with InvalidFee if the fee is not multiple of 100\\n   * @param fee The new swap fee\\n   */\\n  function setSwapFee(uint32 fee) external;\\n\\n  /**\\n   * @notice Sets a new price oracle\\n   * @dev Will revert with ZeroAddress if the zero address is passed\\n   * @param oracle The new oracle contract\\n   */\\n  function setOracle(ITokenPriceOracle oracle) external;\\n\\n  /**\\n   * @notice Sets a new platform fee ratio\\n   * @dev Will revert with HighPlatformFeeRatio if given ratio is too high\\n   * @param platformFeeRatio The new ratio\\n   */\\n  function setPlatformFeeRatio(uint16 platformFeeRatio) external;\\n\\n  /**\\n   * @notice Adds new swap intervals to the allowed list\\n   * @param swapIntervals The new swap intervals\\n   */\\n  function addSwapIntervalsToAllowedList(uint32[] calldata swapIntervals) external;\\n\\n  /**\\n   * @notice Removes some swap intervals from the allowed list\\n   * @param swapIntervals The swap intervals to remove\\n   */\\n  function removeSwapIntervalsFromAllowedList(uint32[] calldata swapIntervals) external;\\n\\n  /// @notice Pauses all swaps and deposits\\n  function pause() external;\\n\\n  /// @notice Unpauses all swaps and deposits\\n  function unpause() external;\\n}\\n\\n/**\\n * @title The interface for handling platform related actions\\n * @notice This contract will handle all actions that affect the platform in some way\\n */\\ninterface IDCAHubPlatformHandler {\\n  /**\\n   * @notice Emitted when someone withdraws from the paltform balance\\n   * @param sender The address of the user that initiated the withdraw\\n   * @param recipient The address that received the withdraw\\n   * @param amounts The tokens (and the amount) that were withdrawn\\n   */\\n  event WithdrewFromPlatform(address indexed sender, address indexed recipient, IDCAHub.AmountOfToken[] amounts);\\n\\n  /**\\n   * @notice Withdraws tokens from the platform balance\\n   * @param amounts The amounts to withdraw\\n   * @param recipient The address that will receive the tokens\\n   */\\n  function withdrawFromPlatformBalance(IDCAHub.AmountOfToken[] calldata amounts, address recipient) external;\\n}\\n\\ninterface IDCAHub is IDCAHubParameters, IDCAHubConfigHandler, IDCAHubSwapHandler, IDCAHubPositionHandler, IDCAHubPlatformHandler {\\n  /// @notice Specifies an amount of a token. For example to determine how much to borrow from certain tokens\\n  struct AmountOfToken {\\n    // The tokens' address\\n    address token;\\n    // How much to borrow or withdraw of the specified token\\n    uint256 amount;\\n  }\\n\\n  /// @notice Thrown when one of the parameters is a zero address\\n  error ZeroAddress();\\n\\n  /// @notice Thrown when the expected liquidity is not returned in flash swaps\\n  error LiquidityNotReturned();\\n\\n  /// @notice Thrown when a list of token pairs is not sorted, or if there are duplicates\\n  error InvalidTokens();\\n}\\n\",\"keccak256\":\"0x4863e91434fa2bca89e8ff16bc35743103a89a39cfc8f9bb963d62fc430f3966\",\"license\":\"GPL-2.0-or-later\"},\"@mean-finance/dca-v2-core/contracts/interfaces/IDCAPermissionManager.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.7 <0.9.0;\\n\\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\\nimport '@mean-finance/nft-descriptors/solidity/interfaces/IDCAHubPositionDescriptor.sol';\\n\\ninterface IERC721BasicEnumerable {\\n  /**\\n   * @notice Count NFTs tracked by this contract\\n   * @return A count of valid NFTs tracked by this contract, where each one of\\n   *         them has an assigned and queryable owner not equal to the zero address\\n   */\\n  function totalSupply() external view returns (uint256);\\n}\\n\\n/**\\n * @title The interface for all permission related matters\\n * @notice These methods allow users to set and remove permissions to their positions\\n */\\ninterface IDCAPermissionManager is IERC721, IERC721BasicEnumerable {\\n  /// @notice Set of possible permissions\\n  enum Permission {\\n    INCREASE,\\n    REDUCE,\\n    WITHDRAW,\\n    TERMINATE\\n  }\\n\\n  /// @notice A set of permissions for a specific operator\\n  struct PermissionSet {\\n    // The address of the operator\\n    address operator;\\n    // The permissions given to the overator\\n    Permission[] permissions;\\n  }\\n\\n  /// @notice A collection of permissions sets for a specific position\\n  struct PositionPermissions {\\n    // The id of the token\\n    uint256 tokenId;\\n    // The permissions to assign to the position\\n    PermissionSet[] permissionSets;\\n  }\\n\\n  /**\\n   * @notice Emitted when permissions for a token are modified\\n   * @param tokenId The id of the token\\n   * @param permissions The set of permissions that were updated\\n   */\\n  event Modified(uint256 tokenId, PermissionSet[] permissions);\\n\\n  /**\\n   * @notice Emitted when the address for a new descritor is set\\n   * @param descriptor The new descriptor contract\\n   */\\n  event NFTDescriptorSet(IDCAHubPositionDescriptor descriptor);\\n\\n  /// @notice Thrown when a user tries to set the hub, once it was already set\\n  error HubAlreadySet();\\n\\n  /// @notice Thrown when a user provides a zero address when they shouldn't\\n  error ZeroAddress();\\n\\n  /// @notice Thrown when a user calls a method that can only be executed by the hub\\n  error OnlyHubCanExecute();\\n\\n  /// @notice Thrown when a user tries to modify permissions for a token they do not own\\n  error NotOwner();\\n\\n  /// @notice Thrown when a user tries to execute a permit with an expired deadline\\n  error ExpiredDeadline();\\n\\n  /// @notice Thrown when a user tries to execute a permit with an invalid signature\\n  error InvalidSignature();\\n\\n  /**\\n   * @notice The permit typehash used in the permit signature\\n   * @return The typehash for the permit\\n   */\\n  // solhint-disable-next-line func-name-mixedcase\\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n  /**\\n   * @notice The permit typehash used in the permission permit signature\\n   * @return The typehash for the permission permit\\n   */\\n  // solhint-disable-next-line func-name-mixedcase\\n  function PERMISSION_PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n  /**\\n   * @notice The permit typehash used in the multi permission permit signature\\n   * @return The typehash for the multi permission permit\\n   */\\n  // solhint-disable-next-line func-name-mixedcase\\n  function MULTI_PERMISSION_PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n  /**\\n   * @notice The permit typehash used in the permission permit signature\\n   * @return The typehash for the permission set\\n   */\\n  // solhint-disable-next-line func-name-mixedcase\\n  function PERMISSION_SET_TYPEHASH() external pure returns (bytes32);\\n\\n  /**\\n   * @notice The permit typehash used in the multi permission permit signature\\n   * @return The typehash for the position permissions\\n   */\\n  // solhint-disable-next-line func-name-mixedcase\\n  function POSITION_PERMISSIONS_TYPEHASH() external pure returns (bytes32);\\n\\n  /**\\n   * @notice The domain separator used in the permit signature\\n   * @return The domain seperator used in encoding of permit signature\\n   */\\n  // solhint-disable-next-line func-name-mixedcase\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n  /**\\n   * @notice Returns the NFT descriptor contract\\n   * @return The contract for the NFT descriptor\\n   */\\n  function nftDescriptor() external returns (IDCAHubPositionDescriptor);\\n\\n  /**\\n   * @notice Returns the address of the DCA Hub\\n   * @return The address of the DCA Hub\\n   */\\n  function hub() external returns (address);\\n\\n  /**\\n   * @notice Returns the next nonce to use for a given user\\n   * @param user The address of the user\\n   * @return nonce The next nonce to use\\n   */\\n  function nonces(address user) external returns (uint256 nonce);\\n\\n  /**\\n   * @notice Returns whether the given address has the permission for the given token\\n   * @param id The id of the token to check\\n   * @param account The address of the user to check\\n   * @param permission The permission to check\\n   * @return Whether the user has the permission or not\\n   */\\n  function hasPermission(\\n    uint256 id,\\n    address account,\\n    Permission permission\\n  ) external view returns (bool);\\n\\n  /**\\n   * @notice Returns whether the given address has the permissions for the given token\\n   * @param id The id of the token to check\\n   * @param account The address of the user to check\\n   * @param permissions The permissions to check\\n   * @return hasPermissions Whether the user has each permission or not\\n   */\\n  function hasPermissions(\\n    uint256 id,\\n    address account,\\n    Permission[] calldata permissions\\n  ) external view returns (bool[] memory hasPermissions);\\n\\n  /**\\n   * @notice Sets the address for the hub\\n   * @dev Can only be successfully executed once. Once it's set, it can be modified again\\n   *      Will revert:\\n   *      - With ZeroAddress if address is zero\\n   *      - With HubAlreadySet if the hub has already been set\\n   * @param hub The address to set for the hub\\n   */\\n  function setHub(address hub) external;\\n\\n  /**\\n   * @notice Mints a new NFT with the given id, and sets the permissions for it\\n   * @dev Will revert with OnlyHubCanExecute if the caller is not the hub\\n   * @param id The id of the new NFT\\n   * @param owner The owner of the new NFT\\n   * @param permissions Permissions to set for the new NFT\\n   */\\n  function mint(\\n    uint256 id,\\n    address owner,\\n    PermissionSet[] calldata permissions\\n  ) external;\\n\\n  /**\\n   * @notice Burns the NFT with the given id, and clears all permissions\\n   * @dev Will revert with OnlyHubCanExecute if the caller is not the hub\\n   * @param id The token's id\\n   */\\n  function burn(uint256 id) external;\\n\\n  /**\\n   * @notice Sets new permissions for the given position\\n   * @dev Will revert with NotOwner if the caller is not the token's owner.\\n   *      Operators that are not part of the given permission sets do not see their permissions modified.\\n   *      In order to remove permissions to an operator, provide an empty list of permissions for them\\n   * @param id The token's id\\n   * @param permissions A list of permission sets\\n   */\\n  function modify(uint256 id, PermissionSet[] calldata permissions) external;\\n\\n  /**\\n   * @notice Sets new permissions for the given positions\\n   * @dev This is basically the same as executing multiple `modify`\\n   * @param permissions A list of position permissions to set\\n   */\\n  function modifyMany(PositionPermissions[] calldata permissions) external;\\n\\n  /**\\n   * @notice Approves spending of a specific token ID by spender via signature\\n   * @param spender The account that is being approved\\n   * @param tokenId The ID of the token that is being approved for spending\\n   * @param deadline The deadline timestamp by which the call must be mined for the approve to work\\n   * @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\\n   * @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\\n   * @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\\n   */\\n  function permit(\\n    address spender,\\n    uint256 tokenId,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external;\\n\\n  /**\\n   * @notice Sets permissions via signature\\n   * @dev This method works similarly to `modifyMany`, but instead of being executed by the owner, it can be set by signature\\n   * @param permissions The permissions to set for the different positions\\n   * @param deadline The deadline timestamp by which the call must be mined for the approve to work\\n   * @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\\n   * @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\\n   * @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\\n   */\\n  function multiPermissionPermit(\\n    PositionPermissions[] calldata permissions,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external;\\n\\n  /**\\n   * @notice Sets permissions via signature\\n   * @dev This method works similarly to `modify`, but instead of being executed by the owner, it can be set my signature\\n   * @param permissions The permissions to set\\n   * @param tokenId The token's id\\n   * @param deadline The deadline timestamp by which the call must be mined for the approve to work\\n   * @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\\n   * @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\\n   * @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\\n   */\\n  function permissionPermit(\\n    PermissionSet[] calldata permissions,\\n    uint256 tokenId,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external;\\n\\n  /**\\n   * @notice Sets a new NFT descriptor\\n   * @dev Will revert with ZeroAddress if address is zero\\n   * @param descriptor The new NFT descriptor contract\\n   */\\n  function setNFTDescriptor(IDCAHubPositionDescriptor descriptor) external;\\n}\\n\",\"keccak256\":\"0x90b20be7552797f8967baa8228b3dfff60e129fa0ec4cf32e136ad0ffeb79f16\",\"license\":\"GPL-2.0-or-later\"},\"@mean-finance/nft-descriptors/solidity/interfaces/IDCAHubPositionDescriptor.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.7 <0.9.0;\\n\\n/**\\n * @title The interface for generating a description for a position in a DCA Hub\\n * @notice Contracts that implement this interface must return a base64 JSON with the entire description\\n */\\ninterface IDCAHubPositionDescriptor {\\n  /**\\n   * @notice Generates a positions's description, both the JSON and the image inside\\n   * @param hub The address of the DCA Hub\\n   * @param positionId The token/position id\\n   * @return description The position's description\\n   */\\n  function tokenURI(address hub, uint256 positionId) external view returns (string memory description);\\n}\\n\",\"keccak256\":\"0x2f5b3f67cf9f0f23be3eb0a8c8edd953ded1dcd8bf074a27e8d2869e200b0a73\",\"license\":\"GPL-2.0-or-later\"},\"@mean-finance/oracles/solidity/interfaces/ITokenPriceOracle.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/**\\n * @title The interface for an oracle that provides price quotes\\n * @notice These methods allow users to add support for pairs, and then ask for quotes\\n */\\ninterface ITokenPriceOracle {\\n  /// @notice Thrown when trying to add support for a pair that cannot be supported\\n  error PairCannotBeSupported(address tokenA, address tokenB);\\n\\n  /// @notice Thrown when trying to execute a quote with a pair that isn't supported yet\\n  error PairNotSupportedYet(address tokenA, address tokenB);\\n\\n  /**\\n   * @notice Returns whether this oracle can support the given pair of tokens\\n   * @dev tokenA and tokenB may be passed in either tokenA/tokenB or tokenB/tokenA order\\n   * @param tokenA One of the pair's tokens\\n   * @param tokenB The other of the pair's tokens\\n   * @return Whether the given pair of tokens can be supported by the oracle\\n   */\\n  function canSupportPair(address tokenA, address tokenB) external view returns (bool);\\n\\n  /**\\n   * @notice Returns whether this oracle is already supporting the given pair of tokens\\n   * @dev tokenA and tokenB may be passed in either tokenA/tokenB or tokenB/tokenA order\\n   * @param tokenA One of the pair's tokens\\n   * @param tokenB The other of the pair's tokens\\n   * @return Whether the given pair of tokens is already being supported by the oracle\\n   */\\n  function isPairAlreadySupported(address tokenA, address tokenB) external view returns (bool);\\n\\n  /**\\n   * @notice Returns a quote, based on the given tokens and amount\\n   * @dev Will revert if pair isn't supported\\n   * @param tokenIn The token that will be provided\\n   * @param amountIn The amount that will be provided\\n   * @param tokenOut The token we would like to quote\\n   * @param data Custom data that the oracle might need to operate\\n   * @return amountOut How much `tokenOut` will be returned in exchange for `amountIn` amount of `tokenIn`\\n   */\\n  function quote(\\n    address tokenIn,\\n    uint256 amountIn,\\n    address tokenOut,\\n    bytes calldata data\\n  ) external view returns (uint256 amountOut);\\n\\n  /**\\n   * @notice Add or reconfigures the support for a given pair. This function will let the oracle take some actions\\n   *         to configure the pair, in preparation for future quotes. Can be called many times in order to let the oracle\\n   *         re-configure for a new context\\n   * @dev Will revert if pair cannot be supported. tokenA and tokenB may be passed in either tokenA/tokenB or tokenB/tokenA order\\n   * @param tokenA One of the pair's tokens\\n   * @param tokenB The other of the pair's tokens\\n   * @param data Custom data that the oracle might need to operate\\n   */\\n  function addOrModifySupportForPair(\\n    address tokenA,\\n    address tokenB,\\n    bytes calldata data\\n  ) external;\\n\\n  /**\\n   * @notice Adds support for a given pair if the oracle didn't support it already. If called for a pair that is already supported,\\n   *         then nothing will happen. This function will let the oracle take some actions to configure the pair, in preparation\\n   *         for future quotes\\n   * @dev Will revert if pair cannot be supported. tokenA and tokenB may be passed in either tokenA/tokenB or tokenB/tokenA order\\n   * @param tokenA One of the pair's tokens\\n   * @param tokenB The other of the pair's tokens\\n   * @param data Custom data that the oracle might need to operate\\n   */\\n  function addSupportForPairIfNeeded(\\n    address tokenA,\\n    address tokenB,\\n    bytes calldata data\\n  ) external;\\n}\\n\",\"keccak256\":\"0xaa43e406144c5108a7f1ac330c434121f4acb7b50b6530dba4e205d2db520a0d\",\"license\":\"GPL-2.0-or-later\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x9750c6b834f7b43000631af5cc30001c5f547b3ceb3635488f140f60e897ea6b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xab28a56179c1db258c9bf5235b382698cb650debecb51b23d12be9e241374b68\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"contracts/MeanFinance/MeanFinanceAdapter.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@mean-finance/dca-v2-core/contracts/interfaces/IDCAHub.sol\\\";\\n\\ncontract MeanFinanceAdapter {\\n    /// @notice MeanFinance IDCAHub contract for deposit\\n    /// @dev see https://docs.mean.finance/guides/smart-contract-registry\\n    IDCAHub public immutable hub =\\n        IDCAHub(0xA5AdC5484f9997fBF7D405b9AA62A7d88883C345);\\n\\n    /// Payable\\n    receive() virtual external payable {}\\n\\n    /// @notice Creates a new position\\n    /// @param _from The address of the \\\"from\\\" token\\n    /// @param _to The address of the \\\"to\\\" token\\n    /// @param _amount How many \\\"from\\\" tokens will be swapped in total\\n    /// @param _amountOfSwaps How many swaps to execute for this position\\n    /// @param _swapInterval How frequently the position's swaps should be executed\\n    /// @param _owner The address of the owner of the position being created\\n    /// @return _positionId The id of the created position\\n    function deposit(\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        uint32 _amountOfSwaps,\\n        uint32 _swapInterval,\\n        address _owner,\\n        IDCAPermissionManager.PermissionSet[] memory _permissions\\n    ) public returns (uint256 _positionId) {\\n        // We need to increase the allowance for the hub before calling deposit\\n        IERC20(_from).approve(address(hub), _amount);\\n        _positionId = hub.deposit(\\n            _from,\\n            _to,\\n            _amount,\\n            _amountOfSwaps,\\n            _swapInterval,\\n            _owner,\\n            _permissions\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x05b2a42979167bfbf584df0de236b59672e5fe490aea8e63577d392845d42c12\",\"license\":\"UNLICENSED\"}},\"version\":1}",
  "bytecode": "0x60a060405273a5adc5484f9997fbf7d405b9aa62a7d88883c34573ffffffffffffffffffffffffffffffffffffffff1660809073ffffffffffffffffffffffffffffffffffffffff1681525034801561005757600080fd5b50608051610b0461007f6000396000818160a30152818160e501526101680152610b046000f3fe60806040526004361061002d5760003560e01c8063365a86fc146100395780636b29e1bd1461006457610034565b3661003457005b600080fd5b34801561004557600080fd5b5061004e6100a1565b60405161005b919061029a565b60405180910390f35b34801561007057600080fd5b5061008b6004803603810190610086919061064e565b6100c5565b604051610098919061071b565b60405180910390f35b7f000000000000000000000000000000000000000000000000000000000000000081565b60008773ffffffffffffffffffffffffffffffffffffffff1663095ea7b37f0000000000000000000000000000000000000000000000000000000000000000886040518363ffffffff1660e01b8152600401610122929190610745565b6020604051808303816000875af1158015610141573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061016591906107a6565b507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16636b29e1bd898989898989896040518863ffffffff1660e01b81526004016101cb9796959493929190610a16565b6020604051808303816000875af11580156101ea573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061020e9190610aa1565b9050979650505050505050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b600061026061025b6102568461021b565b61023b565b61021b565b9050919050565b600061027282610245565b9050919050565b600061028482610267565b9050919050565b61029481610279565b82525050565b60006020820190506102af600083018461028b565b92915050565b6000604051905090565b600080fd5b600080fd5b60006102d48261021b565b9050919050565b6102e4816102c9565b81146102ef57600080fd5b50565b600081359050610301816102db565b92915050565b6000819050919050565b61031a81610307565b811461032557600080fd5b50565b60008135905061033781610311565b92915050565b600063ffffffff82169050919050565b6103568161033d565b811461036157600080fd5b50565b6000813590506103738161034d565b92915050565b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6103c78261037e565b810181811067ffffffffffffffff821117156103e6576103e561038f565b5b80604052505050565b60006103f96102b5565b905061040582826103be565b919050565b600067ffffffffffffffff8211156104255761042461038f565b5b602082029050602081019050919050565b600080fd5b600080fd5b600080fd5b600067ffffffffffffffff8211156104605761045f61038f565b5b602082029050602081019050919050565b6004811061047e57600080fd5b50565b60008135905061049081610471565b92915050565b60006104a96104a484610445565b6103ef565b905080838252602082019050602084028301858111156104cc576104cb610436565b5b835b818110156104f557806104e18882610481565b8452602084019350506020810190506104ce565b5050509392505050565b600082601f83011261051457610513610379565b5b8135610524848260208601610496565b91505092915050565b6000604082840312156105435761054261043b565b5b61054d60406103ef565b9050600061055d848285016102f2565b600083015250602082013567ffffffffffffffff81111561058157610580610440565b5b61058d848285016104ff565b60208301525092915050565b60006105ac6105a78461040a565b6103ef565b905080838252602082019050602084028301858111156105cf576105ce610436565b5b835b8181101561061657803567ffffffffffffffff8111156105f4576105f3610379565b5b808601610601898261052d565b855260208501945050506020810190506105d1565b5050509392505050565b600082601f83011261063557610634610379565b5b8135610645848260208601610599565b91505092915050565b600080600080600080600060e0888a03121561066d5761066c6102bf565b5b600061067b8a828b016102f2565b975050602061068c8a828b016102f2565b965050604061069d8a828b01610328565b95505060606106ae8a828b01610364565b94505060806106bf8a828b01610364565b93505060a06106d08a828b016102f2565b92505060c088013567ffffffffffffffff8111156106f1576106f06102c4565b5b6106fd8a828b01610620565b91505092959891949750929550565b61071581610307565b82525050565b6000602082019050610730600083018461070c565b92915050565b61073f816102c9565b82525050565b600060408201905061075a6000830185610736565b610767602083018461070c565b9392505050565b60008115159050919050565b6107838161076e565b811461078e57600080fd5b50565b6000815190506107a08161077a565b92915050565b6000602082840312156107bc576107bb6102bf565b5b60006107ca84828501610791565b91505092915050565b6107dc8161033d565b82525050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b610817816102c9565b82525050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b6004811061088957610888610849565b5b50565b600081905061089a82610878565b919050565b60006108aa8261088c565b9050919050565b6108ba8161089f565b82525050565b60006108cc83836108b1565b60208301905092915050565b6000602082019050919050565b60006108f08261081d565b6108fa8185610828565b935061090583610839565b8060005b8381101561093657815161091d88826108c0565b9750610928836108d8565b925050600181019050610909565b5085935050505092915050565b600060408301600083015161095b600086018261080e565b506020830151848203602086015261097382826108e5565b9150508091505092915050565b600061098c8383610943565b905092915050565b6000602082019050919050565b60006109ac826107e2565b6109b681856107ed565b9350836020820285016109c8856107fe565b8060005b85811015610a0457848403895281516109e58582610980565b94506109f083610994565b925060208a019950506001810190506109cc565b50829750879550505050505092915050565b600060e082019050610a2b600083018a610736565b610a386020830189610736565b610a45604083018861070c565b610a5260608301876107d3565b610a5f60808301866107d3565b610a6c60a0830185610736565b81810360c0830152610a7e81846109a1565b905098975050505050505050565b600081519050610a9b81610311565b92915050565b600060208284031215610ab757610ab66102bf565b5b6000610ac584828501610a8c565b9150509291505056fea2646970667358221220444002d3a0f711414206117cdb4cd2a5857a535ece2060b22a8a88e151d06f3d64736f6c63430008110033",
  "deployedBytecode": "0x60806040526004361061002d5760003560e01c8063365a86fc146100395780636b29e1bd1461006457610034565b3661003457005b600080fd5b34801561004557600080fd5b5061004e6100a1565b60405161005b919061029a565b60405180910390f35b34801561007057600080fd5b5061008b6004803603810190610086919061064e565b6100c5565b604051610098919061071b565b60405180910390f35b7f000000000000000000000000000000000000000000000000000000000000000081565b60008773ffffffffffffffffffffffffffffffffffffffff1663095ea7b37f0000000000000000000000000000000000000000000000000000000000000000886040518363ffffffff1660e01b8152600401610122929190610745565b6020604051808303816000875af1158015610141573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061016591906107a6565b507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16636b29e1bd898989898989896040518863ffffffff1660e01b81526004016101cb9796959493929190610a16565b6020604051808303816000875af11580156101ea573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061020e9190610aa1565b9050979650505050505050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b600061026061025b6102568461021b565b61023b565b61021b565b9050919050565b600061027282610245565b9050919050565b600061028482610267565b9050919050565b61029481610279565b82525050565b60006020820190506102af600083018461028b565b92915050565b6000604051905090565b600080fd5b600080fd5b60006102d48261021b565b9050919050565b6102e4816102c9565b81146102ef57600080fd5b50565b600081359050610301816102db565b92915050565b6000819050919050565b61031a81610307565b811461032557600080fd5b50565b60008135905061033781610311565b92915050565b600063ffffffff82169050919050565b6103568161033d565b811461036157600080fd5b50565b6000813590506103738161034d565b92915050565b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6103c78261037e565b810181811067ffffffffffffffff821117156103e6576103e561038f565b5b80604052505050565b60006103f96102b5565b905061040582826103be565b919050565b600067ffffffffffffffff8211156104255761042461038f565b5b602082029050602081019050919050565b600080fd5b600080fd5b600080fd5b600067ffffffffffffffff8211156104605761045f61038f565b5b602082029050602081019050919050565b6004811061047e57600080fd5b50565b60008135905061049081610471565b92915050565b60006104a96104a484610445565b6103ef565b905080838252602082019050602084028301858111156104cc576104cb610436565b5b835b818110156104f557806104e18882610481565b8452602084019350506020810190506104ce565b5050509392505050565b600082601f83011261051457610513610379565b5b8135610524848260208601610496565b91505092915050565b6000604082840312156105435761054261043b565b5b61054d60406103ef565b9050600061055d848285016102f2565b600083015250602082013567ffffffffffffffff81111561058157610580610440565b5b61058d848285016104ff565b60208301525092915050565b60006105ac6105a78461040a565b6103ef565b905080838252602082019050602084028301858111156105cf576105ce610436565b5b835b8181101561061657803567ffffffffffffffff8111156105f4576105f3610379565b5b808601610601898261052d565b855260208501945050506020810190506105d1565b5050509392505050565b600082601f83011261063557610634610379565b5b8135610645848260208601610599565b91505092915050565b600080600080600080600060e0888a03121561066d5761066c6102bf565b5b600061067b8a828b016102f2565b975050602061068c8a828b016102f2565b965050604061069d8a828b01610328565b95505060606106ae8a828b01610364565b94505060806106bf8a828b01610364565b93505060a06106d08a828b016102f2565b92505060c088013567ffffffffffffffff8111156106f1576106f06102c4565b5b6106fd8a828b01610620565b91505092959891949750929550565b61071581610307565b82525050565b6000602082019050610730600083018461070c565b92915050565b61073f816102c9565b82525050565b600060408201905061075a6000830185610736565b610767602083018461070c565b9392505050565b60008115159050919050565b6107838161076e565b811461078e57600080fd5b50565b6000815190506107a08161077a565b92915050565b6000602082840312156107bc576107bb6102bf565b5b60006107ca84828501610791565b91505092915050565b6107dc8161033d565b82525050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b610817816102c9565b82525050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b6004811061088957610888610849565b5b50565b600081905061089a82610878565b919050565b60006108aa8261088c565b9050919050565b6108ba8161089f565b82525050565b60006108cc83836108b1565b60208301905092915050565b6000602082019050919050565b60006108f08261081d565b6108fa8185610828565b935061090583610839565b8060005b8381101561093657815161091d88826108c0565b9750610928836108d8565b925050600181019050610909565b5085935050505092915050565b600060408301600083015161095b600086018261080e565b506020830151848203602086015261097382826108e5565b9150508091505092915050565b600061098c8383610943565b905092915050565b6000602082019050919050565b60006109ac826107e2565b6109b681856107ed565b9350836020820285016109c8856107fe565b8060005b85811015610a0457848403895281516109e58582610980565b94506109f083610994565b925060208a019950506001810190506109cc565b50829750879550505050505092915050565b600060e082019050610a2b600083018a610736565b610a386020830189610736565b610a45604083018861070c565b610a5260608301876107d3565b610a5f60808301866107d3565b610a6c60a0830185610736565b81810360c0830152610a7e81846109a1565b905098975050505050505050565b600081519050610a9b81610311565b92915050565b600060208284031215610ab757610ab66102bf565b5b6000610ac584828501610a8c565b9150509291505056fea2646970667358221220444002d3a0f711414206117cdb4cd2a5857a535ece2060b22a8a88e151d06f3d64736f6c63430008110033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "deposit(address,address,uint256,uint32,uint32,address,(address,uint8[])[])": {
        "params": {
          "_amount": "How many \"from\" tokens will be swapped in total",
          "_amountOfSwaps": "How many swaps to execute for this position",
          "_from": "The address of the \"from\" token",
          "_owner": "The address of the owner of the position being created",
          "_swapInterval": "How frequently the position's swaps should be executed",
          "_to": "The address of the \"to\" token"
        },
        "returns": {
          "_positionId": "The id of the created position"
        }
      }
    },
    "stateVariables": {
      "hub": {
        "details": "see https://docs.mean.finance/guides/smart-contract-registry"
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "deposit(address,address,uint256,uint32,uint32,address,(address,uint8[])[])": {
        "notice": "Creates a new position"
      },
      "hub()": {
        "notice": "MeanFinance IDCAHub contract for deposit"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}
